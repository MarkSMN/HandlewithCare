<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CRATE LOADER - Art Handler's Challenge</title>
    
    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="CRATE LOADER – Art Handler's Challenge" />
    <meta property="og:description" content="A fast-paced puzzle game for art handlers and logistics pros." />
    <meta property="og:image" content="https://handlewith-care.vercel.app/coverimage.jpg" />
    <meta property="og:url" content="https://handlewith-care.vercel.app" />
    <meta property="og:type" content="website" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    
    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:image" content="https://handlewith-care.vercel.app/coverimage.jpg" />
    <meta name="twitter:title" content="CRATE LOADER – Art Handler's Challenge" />
    <meta name="twitter:description" content="A fast-paced puzzle game for art handlers and logistics pros." />
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a2e;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            touch-action: none;
        }
        
        .crt {
            position: relative;
        }
        
        .crt::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }
        
        #gameCanvas {
            border: 4px solid #c9a227;
            border-radius: 8px;
            image-rendering: pixelated;
            cursor: crosshair;
            max-height: 90vh;
            max-width: 95vw;
        }
        
        .game-title {
            color: #c9a227;
            font-size: 16px;
            margin-bottom: 8px;
            text-shadow: 2px 2px 0px #8b6914;
            letter-spacing: 2px;
        }
        
        .controls-hint {
            color: #5a6650;
            font-size: 7px;
            margin-bottom: 8px;
            letter-spacing: 1px;
            text-align: center;
        }
        
        .controls-hint span {
            color: #c9a227;
        }
    </style>
</head>
<body>
    <div class="game-title">HANDLE WITH CARE</div>
    <div class="controls-hint">
        <span>[TAP]</span> SELECT &nbsp;&nbsp;&nbsp; 
        <span>[DRAG]</span> MOVE<br>
        <span>[DOUBLE-TAP]</span> ROTATE &nbsp;&nbsp;&nbsp;
        <span>[TAP SCREEN]</span> START
    </div>
    <div class="crt">
        <canvas id="gameCanvas" width="540" height="860"></canvas>
    </div>
    <script>
// CRATE LOADER - Mobile Portrait Version
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Colors
const COLORS = {
    bg: '#2a2a2a',
    warehouseFloor: '#4a4a4a',
    warehouseLine: '#5a5a5a',
    truckBed: '#1a1a1a',
    truckOutline: '#c9a227',
    truckBody: '#4a7c9b',
    truckBodyDark: '#3a6080',
    truckBodyHighlight: '#6a9cbb',
    truckWhite: '#e8e8e8',
    truckWhiteDark: '#cccccc',
    windowGlass: '#1a2a3a',
    mirror: '#3a3a3a',
    headlight: '#fef3c7',
    taillight: '#ef4444',
    brakeLightOn: '#ff0000',
    crate: '#8b6914',
    crateLight: '#c9a227',
    crateDark: '#5a4510',
    crateSelected: '#e8d44d',
    crateValid: '#6b8e23',
    crateInvalid: '#8b3a3a',
    text: '#c9a227',
    textDim: '#7d8471',
    timer: '#c9a227',
    timerLow: '#8b3a3a'
};

const TRUCK_NAMES = {
    trunk: ['COLLECTOR', 'PRIVATE', 'VIP'],
    pickup: ['DIETL', 'HEDLEY\'S', 'RACINE'],
    sprinter: ['CROZIER', 'ATELIER 4', 'CADOGAN'],
    box: ['MASTERPIECE', 'UOVO', 'DIETL'],
    semi: ['CROZIER', 'MASTERPIECE', 'CADOGAN']
};

const VEHICLE_COLORS = [
    { body: '#4a7c9b', highlight: '#6a9cbb', dark: '#3a6080' },
    { body: '#8b4a4a', highlight: '#ab6a6a', dark: '#6b3030' },
    { body: '#4a8b5a', highlight: '#6aab7a', dark: '#306b40' },
    { body: '#7a6b4a', highlight: '#9a8b6a', dark: '#5a4b30' },
    { body: '#5a5a6b', highlight: '#7a7a8b', dark: '#3a3a4b' },
    { body: '#8b7a4a', highlight: '#ab9a6a', dark: '#6b5a30' },
    { body: '#4a5a7b', highlight: '#6a7a9b', dark: '#303a5b' },
    { body: '#6b4a6b', highlight: '#8b6a8b', dark: '#4b304b' },
    { body: '#4a7b7b', highlight: '#6a9b9b', dark: '#305b5b' },
    { body: '#7b5a4a', highlight: '#9b7a6a', dark: '#5b3a30' },
];

const STATES = {
    TITLE: 'title',
    SPLASH: 'splash',
    TRUCK_ENTERING: 'entering',
    PLAYING: 'playing',
    TRUCK_WAITING: 'waiting',
    TRUCK_EXITING: 'exiting',
    WIN: 'win',
    LOSE: 'lose',
    CELEBRATION: 'celebration'
};

// Scaled levels for portrait - trucks come from TOP, warehouse at BOTTOM
const LEVELS = [
    {
        name: "THE PICKUP",
        description: "Small piece for a client",
        truckType: "trunk",
        truckWidth: 100,
        truckHeight: 140,
        timeLimit: 60,
        crates: [{ w: 70, h: 50, label: "BANKSY" }]
    },
    {
        name: "COLLECTOR'S RUN",
        description: "A few pieces uptown",
        truckType: "trunk",
        truckWidth: 110,
        truckHeight: 150,
        timeLimit: 60,
        crates: [
            { w: 60, h: 44, label: "HARING" },
            { w: 70, h: 50, label: "WARHOL" },
            { w: 44, h: 36, label: "KAWS" }
        ]
    },
    {
        name: "WEEKEND WARRIOR",
        description: "Pickup to the art fair",
        truckType: "pickup",
        truckWidth: 140,
        truckHeight: 220,
        timeLimit: 60,
        crates: [
            { w: 80, h: 56, label: "BASQUIAT" },
            { w: 70, h: 64, label: "KUSAMA" },
            { w: 90, h: 50, label: "HOCKNEY" },
            { w: 56, h: 40, label: "KRUGER" }
        ]
    },
    {
        name: "GALLERY INSTALL",
        description: "Sprinter van, group show",
        truckType: "sprinter",
        truckWidth: 180,
        truckHeight: 300,
        timeLimit: 60,
        crates: [
            { w: 100, h: 70, label: "RICHTER" },
            { w: 80, h: 56, label: "PRINCE" },
            { w: 80, h: 56, label: "WOOL" },
            { w: 60, h: 44, label: "STINGEL" },
            { w: 60, h: 44, label: "MURILLO" },
            { w: 50, h: 36, label: "NARA" }
        ]
    },
    {
        name: "BOX TRUCK BLUES",
        description: "Museum loan, careful!",
        truckType: "box",
        truckWidth: 220,
        truckHeight: 400,
        timeLimit: 60,
        crates: [
            { w: 110, h: 76, label: "KOONS" },
            { w: 90, h: 64, label: "HIRST" },
            { w: 90, h: 64, label: "MURAKAMI" },
            { w: 76, h: 52, label: "CATTELAN" },
            { w: 76, h: 52, label: "ABRAMOVIC" },
            { w: 64, h: 44, label: "KAPOOR" },
            { w: 56, h: 40, label: "ELIASSON" },
            { w: 48, h: 36, label: "TURRELL" },
            { w: 48, h: 36, label: "FLAVIN" }
        ]
    },
    {
        name: "THE BIG MOVE",
        description: "53-footer. Big day.",
        truckType: "semi",
        truckWidth: 280,
        truckHeight: 640,
        timeLimit: 60,
        crates: [
            { w: 140, h: 96, label: "SERRA" },
            { w: 116, h: 80, label: "BOURGEOIS" },
            { w: 116, h: 80, label: "GORMLEY" },
            { w: 96, h: 66, label: "JUDD" },
            { w: 96, h: 66, label: "LEWITT" },
            { w: 80, h: 56, label: "SMITHSON" },
            { w: 80, h: 56, label: "DEKOONING" },
            { w: 64, h: 44, label: "ROTHKO" },
            { w: 64, h: 44, label: "POLLOCK" },
            { w: 64, h: 44, label: "TWOMBLY" },
            { w: 52, h: 36, label: "RYMAN" },
            { w: 52, h: 36, label: "MARTIN" },
            { w: 44, h: 32, label: "TUTTLE" }
        ]
    },
    {
        name: "CHAOS MODE",
        description: "Two trucks. Don't ask.",
        truckType: "combo",
        trucks: [
            { type: "trunk", width: 100, height: 130, x: 20 },
            { type: "sprinter", width: 170, height: 280, x: 280 }
        ],
        timeLimit: 60,
        crates: [
            { w: 90, h: 64, label: "FISCHL" },
            { w: 72, h: 52, label: "SCHNABEL" },
            { w: 72, h: 52, label: "SALLE" },
            { w: 56, h: 40, label: "HOLZER" },
            { w: 56, h: 40, label: "SHERMAN" },
            { w: 48, h: 36, label: "LIGON" },
            { w: 48, h: 36, label: "MARSHALL" },
            { w: 40, h: 30, label: "OFILI" }
        ]
    },
    {
        name: "MIAMI MADNESS",
        description: "Two big trucks. Legend.",
        truckType: "double",
        trucks: [
            { type: "box", width: 200, height: 360, x: 5 },
            { type: "box", width: 200, height: 360, x: 270 }
        ],
        timeLimit: 60,
        crates: [
            { w: 104, h: 72, label: "IDENTIFIABLE" },
            { w: 90, h: 60, label: "PICASSO" },
            { w: 90, h: 60, label: "MONET" },
            { w: 76, h: 52, label: "VANGOGH" },
            { w: 76, h: 52, label: "REMBRANDT" },
            { w: 64, h: 44, label: "VERMEER" },
            { w: 64, h: 44, label: "BACON" },
            { w: 64, h: 44, label: "FREUD" },
            { w: 56, h: 40, label: "CLOSE" },
            { w: 56, h: 40, label: "JOHNS" },
            { w: 56, h: 40, label: "DIEBENKORN" },
            { w: 48, h: 34, label: "KELLY" },
            { w: 48, h: 34, label: "STELLA" },
            { w: 48, h: 34, label: "RAUSCHENBERG" },
            { w: 48, h: 34, label: "LICHTENSTEIN" },
            { w: 40, h: 28, label: "OLDENBURG" },
            { w: 40, h: 28, label: "RUSCHA" },
            { w: 36, h: 24, label: "NAUMAN" },
            { w: 36, h: 24, label: "BALDESSARI" }
        ]
    }
];

// Game state
let gameState = STATES.SPLASH;
let currentLevel = 0;
let timeRemaining = 0;
let lastTime = 0;
let crates = [];
let trucks = [];
let selectedCrate = null;
let dragOffset = { x: 0, y: 0 };
let isDragging = false;
let warehouseArea = { x: 0, y: 660, width: 540, height: 200 };

// Animation state
let animationProgress = 0;
let lastBeepTime = 0;
let waitTimer = 0;
const BEEP_INTERVAL = 400;
const TRUCK_SPEED = 200;
const WAIT_DELAY = 1.0;

// Double-tap detection
let lastTapTime = 0;
let lastTapCrate = null;
const DOUBLE_TAP_DELAY = 300;

// Celebration
let celebrationStartTime = 0;
let celebrationScrollY = 0;
let victoryMusicPlayed = false;
const SCROLL_SPEED = 50;

// Splash screen
let splashStartTime = 0;
let splashTextIndex = 0;
let splashTextTimer = 0;
const SPLASH_TEXT = "Looks like you're clocking into the weight room! Good luck!";
const TYPEWRITER_SPEED = 100; // ms per character (slower)
let lastTypedIndex = -1; // Track for sound
let splashImage = new Image();
let splashImageLoaded = false;
splashImage.onload = function() { splashImageLoaded = true; };
splashImage.src = 'splash.png';

// End scene image
let endsceneImage = new Image();
let endsceneImageLoaded = false;
endsceneImage.onload = function() { endsceneImageLoaded = true; };
endsceneImage.src = 'endscene.jpg';

const CREDITS_TEXT = [
    "", "", "CONGRATULATIONS!", "", "",
    "YOU GOT THE JOB!", "", "",
    "- - - - - - - -", "", "",
    "The galleries are closing,", "the mid-tier collectors are", "'taking a pause,'", "",
    "and half the artists", "you're shipping", "have day jobs now.", "", "",
    "But someone still", "needs to move the Serras.", "", "",
    "- - - - - - - -", "", "",
    "Fair season is here.", "", "The mega-galleries have rented", "their usual aircraft hangars.", "",
    "The VIP lounges are stocked", "with champagne no one", "can afford anymore.", "", "",
    "And you?", "", "You're the one making sure", "a $40 million balloon dog", "doesn't get scratched", "by a forklift.", "", "",
    "- - - - - - - -", "", "",
    "The art advisors are", "'cautiously optimistic.'", "", "The auction estimates", "are 'flexible.'", "", "Your back is not.", "", "",
    "- - - - - - - -", "", "",
    "But here's the thing:", "", "Paintings don't", "load themselves.", "", "Sculptures don't", "bubble wrap themselves.", "", "",
    "And when that crate", "marked IDENTIFIABLE", "arrives at 6am", "with no paperwork", "and a nervous gallerist...", "", "you don't ask questions.", "", "",
    "You just handle with care.", "", "",
    "- - - - - - - -", "", "",
    "WELCOME TO THE ART WORLD", "", "The market is volatile.", "", "The trucks must roll.", "", "", "", "",
    "- - - - - - - -", "", "",
    "MARK SCHOENING 2025", "", "", "",
    "", "", "", "[TAP TO CONTINUE]", "", "", ""
];

// Audio
let audioCtx = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

function playSound(type) {
    if (!audioCtx) return;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    switch(type) {
        case 'select':
            osc.frequency.value = 440;
            osc.type = 'square';
            gain.gain.value = 0.1;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
            break;
        case 'place':
            osc.frequency.value = 220;
            osc.type = 'square';
            gain.gain.value = 0.1;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
            break;
        case 'rotate':
            osc.frequency.value = 660;
            osc.type = 'square';
            gain.gain.value = 0.08;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.05);
            break;
        case 'beep':
            osc.frequency.value = 1000;
            osc.type = 'square';
            gain.gain.value = 0.15;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
            break;
        case 'engine':
            osc.frequency.value = 80;
            osc.type = 'sawtooth';
            gain.gain.value = 0.08;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
            break;
        case 'horn':
            osc.frequency.value = 350;
            osc.type = 'square';
            gain.gain.value = 0.12;
            const now = audioCtx.currentTime;
            osc.frequency.setValueAtTime(350, now);
            osc.frequency.setValueAtTime(280, now + 0.15);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start();
            osc.stop(now + 0.4);
            break;
        case 'win':
            const notes = [523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.connect(g);
                g.connect(audioCtx.destination);
                o.frequency.value = freq;
                o.type = 'square';
                g.gain.value = 0.1;
                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15 + i * 0.1);
                o.start(audioCtx.currentTime + i * 0.1);
                o.stop(audioCtx.currentTime + 0.15 + i * 0.1);
            });
            break;
        case 'lose':
            osc.frequency.value = 200;
            osc.type = 'sawtooth';
            gain.gain.value = 0.15;
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
            break;
        case 'start':
            osc.frequency.value = 330;
            osc.type = 'square';
            gain.gain.value = 0.1;
            osc.frequency.exponentialRampToValueAtTime(660, audioCtx.currentTime + 0.15);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
            break;
        case 'type':
            // Short clicky typewriter sound
            osc.frequency.value = 800 + Math.random() * 200;
            osc.type = 'square';
            gain.gain.value = 0.06;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.03);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.03);
            break;
    }
}

function playVictoryFanfare() {
    if (!audioCtx) return;
    const melody = [
        { freq: 523, time: 0, dur: 0.15 }, { freq: 523, time: 0.15, dur: 0.15 },
        { freq: 523, time: 0.3, dur: 0.15 }, { freq: 523, time: 0.45, dur: 0.4 },
        { freq: 415, time: 0.9, dur: 0.15 }, { freq: 466, time: 1.05, dur: 0.15 },
        { freq: 523, time: 1.2, dur: 0.15 }, { freq: 466, time: 1.4, dur: 0.1 },
        { freq: 523, time: 1.55, dur: 0.6 }, { freq: 587, time: 2.3, dur: 0.15 },
        { freq: 587, time: 2.45, dur: 0.15 }, { freq: 587, time: 2.6, dur: 0.15 },
        { freq: 587, time: 2.75, dur: 0.4 }, { freq: 523, time: 3.2, dur: 0.15 },
        { freq: 587, time: 3.35, dur: 0.15 }, { freq: 659, time: 3.5, dur: 0.15 },
        { freq: 587, time: 3.7, dur: 0.1 }, { freq: 659, time: 3.85, dur: 0.8 },
        { freq: 784, time: 4.8, dur: 0.2 }, { freq: 880, time: 5.0, dur: 0.2 },
        { freq: 1047, time: 5.2, dur: 1.0 },
    ];
    const now = audioCtx.currentTime;
    melody.forEach(note => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = note.freq;
        osc.type = 'square';
        gain.gain.value = 0.12;
        gain.gain.exponentialRampToValueAtTime(0.01, now + note.time + note.dur);
        osc.start(now + note.time);
        osc.stop(now + note.time + note.dur + 0.05);
    });
}

// Crate class
class Crate {
    constructor(w, h, label, x, y) {
        this.width = w;
        this.height = h;
        this.label = label;
        this.x = x;
        this.y = y;
        this.rotation = 0;
        this.loaded = false;
        this.valid = true;
    }
    
    get displayWidth() { return this.rotation === 0 ? this.width : this.height; }
    get displayHeight() { return this.rotation === 0 ? this.height : this.width; }
    
    contains(px, py) {
        return px >= this.x && px <= this.x + this.displayWidth &&
               py >= this.y && py <= this.y + this.displayHeight;
    }
    
    rotate() {
        this.rotation = this.rotation === 0 ? 90 : 0;
        playSound('rotate');
    }
    
    draw(selected = false) {
        const w = this.displayWidth;
        const h = this.displayHeight;
        
        let baseColor = COLORS.crate;
        let lightColor = COLORS.crateLight;
        let darkColor = COLORS.crateDark;
        
        if (selected) {
            if (!this.valid) {
                baseColor = COLORS.crateInvalid;
                lightColor = '#c45a5a';
                darkColor = '#5a2020';
            } else if (this.loaded) {
                baseColor = COLORS.crateValid;
                lightColor = '#9bc94d';
                darkColor = '#4a5a20';
            } else {
                baseColor = COLORS.crateSelected;
                lightColor = '#f5e87a';
                darkColor = '#8b7a20';
            }
        }
        
        ctx.fillStyle = baseColor;
        ctx.fillRect(this.x, this.y, w, h);
        
        ctx.fillStyle = lightColor;
        ctx.fillRect(this.x, this.y, w, 2);
        ctx.fillRect(this.x, this.y, 2, h);
        
        ctx.fillStyle = darkColor;
        ctx.fillRect(this.x, this.y + h - 2, w, 2);
        ctx.fillRect(this.x + w - 2, this.y, 2, h);
        
        ctx.fillStyle = selected ? '#000' : lightColor;
        ctx.font = Math.min(11, w/4.5) + 'px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.label, this.x + w/2, this.y + h/2);
    }
}

// Truck class - VERTICAL orientation, BACKING UP (cab at top, cargo opens DOWN toward warehouse)
class Truck {
    constructor(type, bedWidth, bedHeight, x, y) {
        this.type = type;
        this.bedWidth = bedWidth;   // horizontal
        this.bedHeight = bedHeight; // vertical (cargo depth)
        this.x = x;
        this.y = y;  // y is the TOP of the cab
        this.targetY = y;
        this.isReversing = false;
        this.isDriving = false;
        const names = TRUCK_NAMES[type] || ['TRANSPORT'];
        this.companyName = names[Math.floor(Math.random() * names.length)];
        
        const colorPalette = VEHICLE_COLORS[Math.floor(Math.random() * VEHICLE_COLORS.length)];
        this.bodyColor = colorPalette.body;
        this.highlightColor = colorPalette.highlight;
        this.darkColor = colorPalette.dark;
    }
    
    get cabHeight() {
        switch(this.type) {
            case 'trunk': return 45;
            case 'pickup': return 50;
            case 'sprinter': return 40;
            case 'box': return 50;
            case 'semi': return 60;
            default: return 45;
        }
    }
    
    // Bed position - BELOW the cab
    get bedX() { return this.x; }
    get bedY() { return this.y + this.cabHeight; }
    
    get totalHeight() { return this.bedHeight + this.cabHeight; }
    
    update(deltaTime) {
        if (this.isReversing) {
            // Backing up = moving DOWN toward warehouse
            this.y += TRUCK_SPEED * deltaTime;
            if (this.y >= this.targetY) {
                this.y = this.targetY;
                this.isReversing = false;
                return true;
            }
        } else if (this.isDriving) {
            // Driving away = moving UP off screen
            this.y -= TRUCK_SPEED * deltaTime * 1.5;
            if (this.y < -this.totalHeight - 50) {
                return true;
            }
        }
        return false;
    }
    
    draw() {
        // CAB at TOP (nose pointing up), BED opens DOWN toward warehouse
        const cabY = this.y;
        const bedY = this.y + this.cabHeight;
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(this.x + 3, this.y + 3, this.bedWidth, this.totalHeight);
        
        // === CAB (at top, facing up/away) ===
        ctx.fillStyle = this.bodyColor;
        ctx.beginPath();
        ctx.roundRect(this.x, cabY, this.bedWidth, this.cabHeight, [8, 8, 0, 0]);
        ctx.fill();
        
        // Hood at very top (front of vehicle)
        ctx.fillStyle = this.highlightColor;
        ctx.beginPath();
        ctx.roundRect(this.x + 4, cabY + 4, this.bedWidth - 8, this.cabHeight * 0.4, [6, 6, 0, 0]);
        ctx.fill();
        
        // Headlights at top (front)
        ctx.fillStyle = COLORS.headlight;
        ctx.beginPath();
        ctx.arc(this.x + 10, cabY + 8, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + this.bedWidth - 10, cabY + 8, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Windshield (middle of cab)
        ctx.fillStyle = this.darkColor;
        ctx.fillRect(this.x + 5, cabY + this.cabHeight * 0.45, this.bedWidth - 10, 12);
        ctx.fillStyle = COLORS.windowGlass;
        ctx.fillRect(this.x + 8, cabY + this.cabHeight * 0.45 + 2, this.bedWidth - 16, 8);
        
        // Mirrors on sides
        ctx.fillStyle = COLORS.mirror;
        ctx.fillRect(this.x - 4, cabY + this.cabHeight * 0.5, 5, 8);
        ctx.fillRect(this.x + this.bedWidth - 1, cabY + this.cabHeight * 0.5, 5, 8);
        
        // === CARGO BED (opens down toward warehouse) ===
        ctx.fillStyle = COLORS.truckBed;
        ctx.fillRect(this.x, bedY, this.bedWidth, this.bedHeight);
        ctx.strokeStyle = COLORS.truckOutline;
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x, bedY, this.bedWidth, this.bedHeight);
        
        // Bed grid
        ctx.strokeStyle = 'rgba(201, 162, 39, 0.12)';
        ctx.lineWidth = 1;
        const gridSize = 18;
        for (let gx = this.x + gridSize; gx < this.x + this.bedWidth; gx += gridSize) {
            ctx.beginPath();
            ctx.moveTo(gx, bedY);
            ctx.lineTo(gx, bedY + this.bedHeight);
            ctx.stroke();
        }
        for (let gy = bedY + gridSize; gy < bedY + this.bedHeight; gy += gridSize) {
            ctx.beginPath();
            ctx.moveTo(this.x, gy);
            ctx.lineTo(this.x + this.bedWidth, gy);
            ctx.stroke();
        }
        
        // Taillights at BOTTOM of bed (rear of vehicle, facing warehouse)
        ctx.fillStyle = this.isReversing ? COLORS.brakeLightOn : COLORS.taillight;
        ctx.fillRect(this.x + 3, bedY + this.bedHeight - 7, 8, 5);
        ctx.fillRect(this.x + this.bedWidth - 11, bedY + this.bedHeight - 7, 8, 5);
        
        // Reverse lights (white, next to taillights)
        if (this.isReversing) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(this.x + 13, bedY + this.bedHeight - 7, 6, 5);
            ctx.fillRect(this.x + this.bedWidth - 19, bedY + this.bedHeight - 7, 6, 5);
        }
        
        // Company name on cab
        ctx.fillStyle = COLORS.textDim;
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.companyName, this.x + this.bedWidth/2, cabY - 12);
    }
}

// Initialize level
function initLevel(levelIndex) {
    const level = LEVELS[levelIndex];
    crates = [];
    trucks = [];
    selectedCrate = null;
    timeRemaining = level.timeLimit;
    animationProgress = 0;
    lastBeepTime = 0;
    waitTimer = 0;
    
    // Warehouse at bottom
    warehouseArea.y = canvas.height - 180;
    warehouseArea.height = 180;
    warehouseArea.width = canvas.width;
    
    // Gap between bed bottom and warehouse top
    const dockGap = 8;
    
    if (level.truckType === 'combo' || level.truckType === 'double') {
        level.trucks.forEach(t => {
            // Create truck starting off-screen (above canvas)
            const truck = new Truck(t.type, t.width, t.height, t.x, -200);
            // targetY positions the cab top so that bed bottom is at warehouse edge
            // bedY = y + cabHeight, bedBottom = y + cabHeight + bedHeight
            // We want: y + cabHeight + bedHeight = warehouseArea.y - dockGap
            // So: y = warehouseArea.y - dockGap - cabHeight - bedHeight
            truck.targetY = warehouseArea.y - dockGap - truck.cabHeight - t.height;
            truck.isReversing = true;
            trucks.push(truck);
        });
    } else {
        const truckX = (canvas.width - level.truckWidth) / 2;
        const truck = new Truck(
            level.truckType,
            level.truckWidth,
            level.truckHeight,
            truckX,
            -200  // Start off-screen above
        );
        // Position so bed bottom is at warehouse edge
        truck.targetY = warehouseArea.y - dockGap - truck.cabHeight - level.truckHeight;
        truck.isReversing = true;
        trucks.push(truck);
    }
    
    // Overlapping crate pile - realistic warehouse staging
    const padding = 4;
    const overlapX = 0.6; // Crates overlap 40% horizontally
    const overlapY = 0.5; // Crates overlap 50% vertically
    
    // Sort crates by size (largest first) - big ones on bottom
    const sortedCrates = [...level.crates].sort((a, b) => (b.w * b.h) - (a.w * a.h));
    
    // Calculate pile layout
    let crateX = 15;
    let crateY = warehouseArea.y + 15;
    let rowStartY = crateY;
    let maxHeightInRow = 0;
    const maxWidth = canvas.width - 30;
    
    sortedCrates.forEach((crateData, index) => {
        // Check if we need to wrap to next row
        if (crateX + crateData.w > maxWidth) {
            crateX = 15 + (index % 3) * 20; // Stagger each row slightly
            crateY = rowStartY + maxHeightInRow * overlapY;
            rowStartY = crateY;
            maxHeightInRow = 0;
        }
        
        // Add some random offset for natural pile look
        const offsetX = (Math.random() - 0.5) * 10;
        const offsetY = (Math.random() - 0.5) * 8;
        
        crates.push(new Crate(
            crateData.w, 
            crateData.h, 
            crateData.label, 
            crateX + offsetX, 
            crateY + offsetY
        ));
        
        crateX += crateData.w * overlapX;
        maxHeightInRow = Math.max(maxHeightInRow, crateData.h);
    });
    
    gameState = STATES.TRUCK_ENTERING;
    playSound('start');
}

function cratesCollide(c1, c2) {
    if (c1 === c2) return false;
    return !(c1.x + c1.displayWidth <= c2.x ||
             c2.x + c2.displayWidth <= c1.x ||
             c1.y + c1.displayHeight <= c2.y ||
             c2.y + c2.displayHeight <= c1.y);
}

function isInTruck(crate) {
    for (const truck of trucks) {
        if (crate.x >= truck.bedX &&
            crate.y >= truck.bedY &&
            crate.x + crate.displayWidth <= truck.bedX + truck.bedWidth &&
            crate.y + crate.displayHeight <= truck.bedY + truck.bedHeight) {
            return true;
        }
    }
    return false;
}

function updateCrateValidity() {
    crates.forEach(crate => {
        crate.loaded = isInTruck(crate);
        let collides = false;
        crates.forEach(other => {
            if (cratesCollide(crate, other)) collides = true;
        });
        crate.valid = !collides;
    });
}

function checkWin() {
    return crates.every(c => c.loaded && c.valid);
}

function drawBackground() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawWarehouse() {
    ctx.fillStyle = COLORS.warehouseFloor;
    ctx.fillRect(0, warehouseArea.y, warehouseArea.width, warehouseArea.height);
    
    ctx.strokeStyle = COLORS.warehouseLine;
    ctx.lineWidth = 1;
    ctx.setLineDash([8, 8]);
    for (let x = 40; x < warehouseArea.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, warehouseArea.y + 10);
        ctx.lineTo(x, warehouseArea.y + warehouseArea.height - 10);
        ctx.stroke();
    }
    ctx.setLineDash([]);
    
    ctx.strokeStyle = COLORS.textDim;
    ctx.lineWidth = 3;
    ctx.strokeRect(0, warehouseArea.y, warehouseArea.width, warehouseArea.height);
    
    // Dock door at top
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(20, warehouseArea.y - 4, warehouseArea.width - 40, 6);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('WAREHOUSE', canvas.width/2, warehouseArea.y + warehouseArea.height - 8);
}

function drawUI() {
    const level = LEVELS[currentLevel];
    ctx.fillStyle = COLORS.text;
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText('LVL ' + (currentLevel + 1), 12, 28);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '17px "Press Start 2P", monospace';
    ctx.fillText(level.name, 12, 50);
    
    const timerColor = timeRemaining <= 10 ? COLORS.timerLow : COLORS.timer;
    ctx.fillStyle = timerColor;
    ctx.font = '18px "Press Start 2P", monospace';
    ctx.textAlign = 'right';
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = Math.floor(timeRemaining % 60);
    ctx.fillText(minutes + ':' + seconds.toString().padStart(2, '0'), canvas.width - 12, 28);
    
    const loadedCount = crates.filter(c => c.loaded && c.valid).length;
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '12px "Press Start 2P", monospace';
    ctx.fillText(loadedCount + '/' + crates.length, canvas.width - 12, 48);
}

function drawTitleScreen() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = COLORS.text;
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CRATE', canvas.width/2, 200);
    ctx.fillText('LOADER', canvas.width/2, 240);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.fillText("ART HANDLER'S", canvas.width/2, 290);
    ctx.fillText("CHALLENGE", canvas.width/2, 310);
    
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.fillText('Load crates into', canvas.width/2, 400);
    ctx.fillText('the truck before', canvas.width/2, 420);
    ctx.fillText('time runs out!', canvas.width/2, 440);
    
    ctx.fillStyle = COLORS.text;
    ctx.fillText('TAP to select', canvas.width/2, 520);
    ctx.fillText('DRAG to move', canvas.width/2, 545);
    ctx.fillText('DOUBLE-TAP to rotate', canvas.width/2, 570);
    
    if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.font = '10px "Press Start 2P", monospace';
        ctx.fillText('TAP TO START', canvas.width/2, 700);
    }
}

function drawSplashScreen() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw image full width
    if (splashImageLoaded) {
        const imgSize = canvas.width; // Full width
        const imgX = 0;
        const imgY = 80;
        
        // Draw pixelated (disable smoothing)
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(splashImage, imgX, imgY, imgSize, imgSize);
    }
    
    const now = Date.now();
    
    // If typing hasn't started yet, show tap prompt
    if (splashStartTime === 0) {
        if (Math.floor(now / 500) % 2 === 0) {
            ctx.fillStyle = COLORS.text;
            ctx.font = '12px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('[TAP TO START]', canvas.width/2, 720);
        }
        return;
    }
    
    // Typewriter text
    const elapsed = now - splashStartTime;
    splashTextIndex = Math.min(Math.floor(elapsed / TYPEWRITER_SPEED), SPLASH_TEXT.length);
    
    // Play typing sound when new character appears
    if (splashTextIndex > lastTypedIndex && splashTextIndex <= SPLASH_TEXT.length) {
        // Only play sound for non-space characters
        if (SPLASH_TEXT[splashTextIndex - 1] !== ' ') {
            playSound('type');
        }
        lastTypedIndex = splashTextIndex;
    }
    
    const displayText = SPLASH_TEXT.substring(0, splashTextIndex);
    
    ctx.fillStyle = COLORS.text;
    ctx.font = '16px "Press Start 2P", monospace'; // 2x bigger
    ctx.textAlign = 'center';
    
    // Word wrap the text
    const words = displayText.split(' ');
    let lines = [];
    let currentLine = '';
    const maxWidth = 480;
    
    for (let word of words) {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    }
    if (currentLine) lines.push(currentLine);
    
    const lineHeight = 40; // Bigger line height for bigger text
    const textStartY = 660;
    lines.forEach((line, i) => {
        ctx.fillText(line, canvas.width/2, textStartY + i * lineHeight);
    });
    
    // Blinking cursor at end of text
    if (splashTextIndex < SPLASH_TEXT.length) {
        if (Math.floor(now / 300) % 2 === 0) {
            const lastLine = lines[lines.length - 1] || '';
            const cursorX = canvas.width/2 + ctx.measureText(lastLine).width/2 + 5;
            const cursorY = textStartY + (lines.length - 1) * lineHeight;
            ctx.fillRect(cursorX, cursorY - 12, 12, 16);
        }
    }
    
    // Show "tap to continue" after text is done
    if (splashTextIndex >= SPLASH_TEXT.length) {
        if (Math.floor(now / 500) % 2 === 0) {
            ctx.fillStyle = COLORS.textDim;
            ctx.font = '10px "Press Start 2P", monospace';
            ctx.fillText('[TAP TO CONTINUE]', canvas.width/2, 800);
        }
    }
}

function drawWinScreen() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = COLORS.crateValid;
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('TRUCK LOADED!', canvas.width/2, 350);
    
    ctx.fillStyle = COLORS.text;
    ctx.font = '10px "Press Start 2P", monospace';
    ctx.fillText('TIME BONUS: ' + Math.floor(timeRemaining * 10), canvas.width/2, 400);
    
    if (currentLevel < LEVELS.length - 1) {
        if (Math.floor(Date.now() / 500) % 2 === 0) {
            ctx.fillText('TAP FOR NEXT LEVEL', canvas.width/2, 500);
        }
    } else {
        if (Math.floor(Date.now() / 500) % 2 === 0) {
            ctx.fillText('TAP TO CELEBRATE', canvas.width/2, 500);
        }
    }
}

function drawLoseScreen() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = COLORS.crateInvalid;
    ctx.font = '18px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('TIME UP!', canvas.width/2, 350);
    
    ctx.fillStyle = COLORS.textDim;
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.fillText('The client is', canvas.width/2, 400);
    ctx.fillText('not happy...', canvas.width/2, 420);
    
    if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.fillStyle = COLORS.text;
        ctx.fillText('TAP TO RETRY', canvas.width/2, 500);
    }
}

function drawCelebration(deltaTime) {
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw endscene image in top 1/3
    const imageAreaHeight = Math.floor(canvas.height / 3);
    if (endsceneImageLoaded) {
        // Calculate dimensions to fill width while maintaining aspect ratio
        const imgAspect = endsceneImage.width / endsceneImage.height;
        const drawWidth = canvas.width;
        const drawHeight = drawWidth / imgAspect;
        const imgY = (imageAreaHeight - drawHeight) / 2;
        
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(endsceneImage, 0, imgY, drawWidth, drawHeight);
    }
    
    // Draw divider line below image
    ctx.strokeStyle = COLORS.textDim;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(20, imageAreaHeight);
    ctx.lineTo(canvas.width - 20, imageAreaHeight);
    ctx.stroke();
    
    // Scrolling stars in credits area only
    const starTime = Date.now() / 50;
    ctx.fillStyle = '#333';
    for (let i = 0; i < 20; i++) {
        const x = (i * 73 + starTime) % canvas.width;
        const y = imageAreaHeight + ((i * 47) % (canvas.height - imageAreaHeight));
        ctx.fillRect(x, y, 2, 2);
    }
    
    celebrationScrollY += SCROLL_SPEED * deltaTime;
    
    // Clip credits to bottom 2/3
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, imageAreaHeight, canvas.width, canvas.height - imageAreaHeight);
    ctx.clip();
    
    ctx.font = '12px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    
    const lineHeight = 34;
    const creditsAreaHeight = canvas.height - imageAreaHeight;
    const startY = canvas.height - celebrationScrollY;
    
    CREDITS_TEXT.forEach((line, index) => {
        const y = startY + index * lineHeight;
        if (y > imageAreaHeight - 30 && y < canvas.height + 30) {
            if (line === 'CONGRATULATIONS!') {
                ctx.fillStyle = COLORS.text;
                ctx.font = '18px "Press Start 2P", monospace';
            } else if (line === 'YOU GOT THE JOB!') {
                ctx.fillStyle = COLORS.crateValid;
                ctx.font = '14px "Press Start 2P", monospace';
            } else if (line === '[TAP TO CONTINUE]') {
                if (Math.floor(Date.now() / 500) % 2 === 0) {
                    ctx.fillStyle = COLORS.text;
                } else {
                    ctx.fillStyle = 'transparent';
                }
                ctx.font = '11px "Press Start 2P", monospace';
            } else if (line.includes('- - -')) {
                ctx.fillStyle = COLORS.truckOutline;
                ctx.font = '10px "Press Start 2P", monospace';
            } else {
                ctx.fillStyle = COLORS.textDim;
                ctx.font = '11px "Press Start 2P", monospace';
            }
            ctx.fillText(line, canvas.width / 2, y);
        }
    });
    
    ctx.restore();
}

let winSoundPlayed = false;
let loseSoundPlayed = false;

function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (gameState === STATES.TITLE) {
        drawTitleScreen();
        winSoundPlayed = false;
        loseSoundPlayed = false;
    } else if (gameState === STATES.SPLASH) {
        drawSplashScreen();
    } else if (gameState === STATES.TRUCK_ENTERING) {
        drawBackground();
        drawWarehouse();
        
        let allArrived = true;
        trucks.forEach(truck => {
            if (truck.isReversing) {
                if (!truck.update(deltaTime)) {
                    allArrived = false;
                }
            }
            truck.draw();
        });
        
        if (timestamp - lastBeepTime > BEEP_INTERVAL) {
            playSound('beep');
            lastBeepTime = timestamp;
        }
        
        crates.forEach(c => c.draw(false));
        drawUI();
        
        if (allArrived) {
            trucks.forEach(t => t.isReversing = false);
            gameState = STATES.PLAYING;
        }
    } else if (gameState === STATES.PLAYING) {
        timeRemaining -= deltaTime;
        if (timeRemaining <= 0) {
            timeRemaining = 0;
            gameState = STATES.LOSE;
        }
        updateCrateValidity();
        
        if (checkWin()) {
            waitTimer = 0;
            gameState = STATES.TRUCK_WAITING;
        }
        
        drawBackground();
        drawWarehouse();
        trucks.forEach(t => t.draw());
        crates.forEach(c => { if (c !== selectedCrate) c.draw(false); });
        if (selectedCrate) selectedCrate.draw(true);
        drawUI();
    } else if (gameState === STATES.TRUCK_WAITING) {
        waitTimer += deltaTime;
        drawBackground();
        drawWarehouse();
        trucks.forEach(t => t.draw());
        crates.forEach(c => c.draw(false));
        drawUI();
        
        if (waitTimer >= WAIT_DELAY) {
            trucks.forEach(t => t.isDriving = true);
            gameState = STATES.TRUCK_EXITING;
            playSound('horn');
        }
    } else if (gameState === STATES.TRUCK_EXITING) {
        drawBackground();
        drawWarehouse();
        
        let allGone = true;
        trucks.forEach(truck => {
            if (truck.isDriving) {
                if (!truck.update(deltaTime)) {
                    allGone = false;
                }
            }
            truck.draw();
        });
        
        crates.forEach(c => {
            if (c.loaded) {
                c.y -= TRUCK_SPEED * deltaTime * 1.5;
            }
            c.draw(false);
        });
        
        if (timestamp - lastBeepTime > 300) {
            playSound('engine');
            lastBeepTime = timestamp;
        }
        
        drawUI();
        
        if (allGone) {
            gameState = STATES.WIN;
        }
    } else if (gameState === STATES.WIN) {
        if (!winSoundPlayed) { playSound('win'); winSoundPlayed = true; }
        drawBackground();
        drawWarehouse();
        drawUI();
        drawWinScreen();
    } else if (gameState === STATES.CELEBRATION) {
        if (!victoryMusicPlayed) {
            playVictoryFanfare();
            victoryMusicPlayed = true;
            celebrationScrollY = 0;
        }
        drawCelebration(deltaTime);
    } else if (gameState === STATES.LOSE) {
        if (!loseSoundPlayed) { playSound('lose'); loseSoundPlayed = true; }
        drawBackground();
        drawWarehouse();
        trucks.forEach(t => t.draw());
        crates.forEach(c => c.draw(false));
        drawUI();
        drawLoseScreen();
    }
    
    requestAnimationFrame(gameLoop);
}

// Input handling - unified for mouse and touch
function getEventPos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    if (e.touches && e.touches.length > 0) {
        return {
            x: (e.touches[0].clientX - rect.left) * scaleX,
            y: (e.touches[0].clientY - rect.top) * scaleY
        };
    } else if (e.changedTouches && e.changedTouches.length > 0) {
        return {
            x: (e.changedTouches[0].clientX - rect.left) * scaleX,
            y: (e.changedTouches[0].clientY - rect.top) * scaleY
        };
    } else {
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }
}

function handleStart(e) {
    e.preventDefault();
    initAudio();
    
    const pos = getEventPos(e);
    
    // Handle non-playing states
    if (gameState === STATES.SPLASH) {
        // First tap starts the typing, second tap (after done) starts game
        if (splashStartTime === 0) {
            // Start typing on first tap
            splashStartTime = Date.now();
            lastTypedIndex = -1;
        } else if (splashTextIndex >= SPLASH_TEXT.length) {
            // Start game after typing is done
            initLevel(0);
        }
        return;
    } else if (gameState === STATES.WIN) {
        winSoundPlayed = false;
        if (currentLevel < LEVELS.length - 1) {
            currentLevel++;
            initLevel(currentLevel);
        } else {
            gameState = STATES.CELEBRATION;
            victoryMusicPlayed = false;
            celebrationScrollY = 0;
        }
        return;
    } else if (gameState === STATES.CELEBRATION) {
        currentLevel = 0;
        gameState = STATES.SPLASH;
        splashStartTime = 0;
        splashTextIndex = 0;
        lastTypedIndex = -1;
        return;
    } else if (gameState === STATES.LOSE) {
        loseSoundPlayed = false;
        initLevel(currentLevel);
        return;
    }
    
    if (gameState !== STATES.PLAYING) return;
    
    // Find clicked crate
    let clickedCrate = null;
    for (let i = crates.length - 1; i >= 0; i--) {
        if (crates[i].contains(pos.x, pos.y)) {
            clickedCrate = crates[i];
            crates.splice(i, 1);
            crates.push(clickedCrate);
            break;
        }
    }
    
    if (clickedCrate) {
        const now = Date.now();
        
        // Check for double-tap on same crate
        if (clickedCrate === lastTapCrate && now - lastTapTime < DOUBLE_TAP_DELAY) {
            clickedCrate.rotate();
            lastTapTime = 0;
            lastTapCrate = null;
        } else {
            if (clickedCrate !== selectedCrate) {
                selectedCrate = clickedCrate;
                playSound('select');
            }
            dragOffset.x = pos.x - selectedCrate.x;
            dragOffset.y = pos.y - selectedCrate.y;
            isDragging = true;
            lastTapTime = now;
            lastTapCrate = clickedCrate;
        }
    } else {
        selectedCrate = null;
        lastTapCrate = null;
    }
}

function handleMove(e) {
    e.preventDefault();
    if (!isDragging || !selectedCrate) return;
    
    const pos = getEventPos(e);
    selectedCrate.x = pos.x - dragOffset.x;
    selectedCrate.y = pos.y - dragOffset.y;
    selectedCrate.x = Math.max(0, Math.min(canvas.width - selectedCrate.displayWidth, selectedCrate.x));
    selectedCrate.y = Math.max(0, Math.min(canvas.height - selectedCrate.displayHeight, selectedCrate.y));
}

function handleEnd(e) {
    e.preventDefault();
    if (isDragging && selectedCrate) playSound('place');
    isDragging = false;
}

// Mouse events
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);

// Touch events
canvas.addEventListener('touchstart', handleStart, { passive: false });
canvas.addEventListener('touchmove', handleMove, { passive: false });
canvas.addEventListener('touchend', handleEnd, { passive: false });
canvas.addEventListener('touchcancel', handleEnd, { passive: false });

// Keyboard (still works on desktop)
document.addEventListener('keydown', function(e) {
    if (e.code === 'Space') {
        e.preventDefault();
        initAudio();
        if (gameState === STATES.SPLASH) {
            if (splashStartTime === 0) {
                splashStartTime = Date.now();
                lastTypedIndex = -1;
            } else if (splashTextIndex >= SPLASH_TEXT.length) {
                initLevel(0);
            }
        } else if (gameState === STATES.WIN) {
            winSoundPlayed = false;
            if (currentLevel < LEVELS.length - 1) {
                currentLevel++;
                initLevel(currentLevel);
            } else {
                gameState = STATES.CELEBRATION;
                victoryMusicPlayed = false;
            }
        } else if (gameState === STATES.CELEBRATION) {
            currentLevel = 0;
            gameState = STATES.SPLASH;
            splashStartTime = 0;
            splashTextIndex = 0;
            lastTypedIndex = -1;
        } else if (gameState === STATES.LOSE) {
            loseSoundPlayed = false;
            initLevel(currentLevel);
        }
    }
    if (e.code === 'KeyR' && gameState === STATES.PLAYING && selectedCrate) {
        selectedCrate.rotate();
    }
    // K = skip to next level (debug/testing)
    if (e.code === 'KeyK') {
        initAudio();
        // Skip splash to game
        if (gameState === STATES.SPLASH) {
            initLevel(0);
        } else if (currentLevel < LEVELS.length - 1) {
            initLevel(0);
        } else if (currentLevel < LEVELS.length - 1) {
            currentLevel++;
            initLevel(currentLevel);
        } else {
            gameState = STATES.CELEBRATION;
            victoryMusicPlayed = false;
            celebrationScrollY = 0;
        }
    }
});

requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
